<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>H·ªçc sinh DHE & Mr. "Bi·∫øt Tu·ªët 4.0".</title>
  <style>
  /* Reset + mobile-first layout */
  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    padding: 0;
    background: #f4f7ff;
    display: flex;
    justify-content: center;
    align-items: flex-start;
  }

  .card {
    background: white;
    margin: 16px;
    padding: 20px;
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.08);
    text-align: center;
    min-width: 400px;
  }

  h2 {
    font-size: 1.4rem;
    margin: 0 0 6px;
  }

  p {
    font-size: 0.95rem;
    color: #4b5563;
    margin-top: 4px;
    margin-bottom: 12px;
  }

  button {
    padding: 12px 20px;
    border-radius: 999px;
    border: none;
    font-size: 1rem;
    margin: 6px;
    cursor: pointer;
  }

  #startBtn {
    background: #2563eb;
    color: #fff;
  }
  #stopBtn {
    background: #ef4444;
    color: #fff;
  }

  #status {
    margin-top: 10px;
    font-size: 0.9rem;
    color: #555;
    min-height: 18px;
  }

  /* Danh s√°ch b∆∞·ªõc pipeline */
  #pipeline-steps {
    margin-top: 8px;
    text-align: left;
  }
  .pipeline-step {
    font-size: 0.85rem;
    color: #4b5563;
    margin-top: 2px;
  }
  .pipeline-step.active {
    color: #111827;
    font-weight: 600;
  }
  .pipeline-check {
    margin-left: 6px;
    color: #16a34a;
    font-weight: 700;
  }
  #step5Timer {
    margin-left: 6px;
    color: #2563eb;
  }

  /* Avatar (n·∫øu sau n√†y th√™m) */
  #avatar-wrapper {
    margin-top: 14px;
  }
  #avatar {
    width: 120px;
    height: 120px;
  }

  /* Waveform */
  #waveformCanvas {
    margin-top: 16px;
    border-radius: 12px;
    background: #e5e7eb;
    width: 100%;
    max-width: 320px;
  }

  #transcript,
  #aiText {
    margin-top: 12px;
    padding: 10px 14px;
    border-radius: 8px;
    background: #f9fafb;
    font-size: 0.9rem;
    text-align: left;
    white-space: pre-wrap;
  }

  audio {
    margin-top: 12px;
    width: 100%;
  }

  /* ====== MEDIA QUERIES ====== */

  /* Tablet & desktop: scale up */
  @media (min-width: 600px) {
    h2 {
      font-size: 1.6rem;
    }
    button {
      font-size: 1.1rem;
      padding: 12px 24px;
    }
    #avatar {
      width: 140px;
      height: 140px;
    }
    #waveformCanvas {
      max-width: 360px;
      height: 60px;
    }
  }

  @media (min-width: 900px) {
    .card {
      padding: 28px 36px;
    }
    #avatar {
      width: 160px;
      height: 160px;
    }
    p {
      font-size: 1rem;
    }
  }
  </style>
</head>
<body>

<div class="card">
  <h2>üéß H·ªçc sinh DHE & Mr. "Bi·∫øt Tu·ªët 4.0"</h2>
  <p>ƒê·ªÉ b·∫Øt ƒë·∫ßu, h√£y b·∫•m <b>Start</b> r·ªìi n√≥i v√†o mic.<br>Khi n√≥i xong h√£y b·∫•m <b>Stop</b> (ho·∫∑c ng∆∞ng trong 3 gi√¢y),<br>M√¨nh s·∫Ω bi√™n t·∫≠p th√¥ng tin v√† tr·∫£ l·ªùi b·∫±ng gi·ªçng n√≥i.</p>

  <div>
    <button id="startBtn">üéô Start</button>
    <button id="stopBtn" disabled>‚èπ Stop</button>
  </div>

  <div id="status">Ch∆∞a ghi √¢m.</div>

  <!-- Danh s√°ch 6 b∆∞·ªõc pipeline -->
  <div id="pipeline-steps"></div>

  <div id="transcript"><b>H·ªçc sinh n√≥i:</b> (ch∆∞a c√≥)</div>
  <div id="aiText"><b>AI tr·∫£ l·ªùi:</b> (ch∆∞a c√≥)</div>

  <audio id="audioPlayer" controls style="margin-top: 12px; width: 100%; display:none;"></audio>
</div>

<script>
  let mediaRecorder;
  let audioChunks = [];

  let audioContext;
  let analyser;
  let microphone;
  let animationId = null;

  let lastSoundTime = 0;
  const SILENCE_LIMIT = 3000; // 3 gi√¢y

  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const statusEl = document.getElementById("status");
  const transcriptEl = document.getElementById("transcript");
  const aiTextEl = document.getElementById("aiText");
  const audioPlayer = document.getElementById("audioPlayer");

  // ====== PIPELINE TR·∫†NG TH√ÅI B1..B6 ======
  const pipelineContainer = document.getElementById("pipeline-steps");

  const pipelineStepsConfig = [
    { id: 1, text: "B1: ƒêang t·∫£i d·ªØ li·ªáu l√™n h·ªá th·ªëng" },
    { id: 2, text: "B2: ƒêang chuy·ªÉn gi·ªçng n√≥i sang vƒÉn b·∫£n" },
    { id: 3, text: "B3: ƒêang truy c·∫≠p v√† ph√¢n t√≠ch big data c·ªßa nh√† tr∆∞·ªùng" },
    { id: 4, text: "B4: ƒêang chu·∫©n h√≥a v√† bi√™n t·∫≠p c√¢u tr·∫£ l·ªùi" },
    { id: 5, text: "B5: ƒêang t·∫°o file √¢m thanh tr·∫£ l·ªùi" },
    { id: 6, text: "B6: ƒêang ph√°t file √¢m thanh cho b·∫°n nghe" },
  ];

  const stepElements = {}; // { id: {root, textSpan, checkSpan, timerSpan?} }

  // T·∫°o UI b∆∞·ªõc
  pipelineStepsConfig.forEach((step) => {
    const div = document.createElement("div");
    div.className = "pipeline-step";
    div.dataset.step = step.id;

    const textSpan = document.createElement("span");
    textSpan.className = "pipeline-text";
    textSpan.textContent = step.text;

    const timerSpan = document.createElement("span");
    if (step.id === 5) {
      timerSpan.id = "step5Timer";
    }

    const checkSpan = document.createElement("span");
    checkSpan.className = "pipeline-check";

    div.appendChild(textSpan);
    if (step.id === 5) div.appendChild(timerSpan);
    div.appendChild(checkSpan);

    pipelineContainer.appendChild(div);

    stepElements[step.id] = {
      root: div,
      textSpan,
      checkSpan,
      timerSpan: step.id === 5 ? timerSpan : null,
    };
  });

  function clearActiveSteps() {
    Object.values(stepElements).forEach((s) => {
      s.root.classList.remove("active");
    });
  }

  function resetPipelineStepsUI() {
    clearActiveSteps();
    Object.values(stepElements).forEach((s) => {
      s.checkSpan.textContent = "";
      if (s.timerSpan) s.timerSpan.textContent = "";
    });
  }

  function setStepActive(stepId) {
    clearActiveSteps();
    const step = stepElements[stepId];
    if (step) {
      step.root.classList.add("active");
    }
  }

  function markStepDone(stepId) {
    const step = stepElements[stepId];
    if (step) {
      if (!step.checkSpan.textContent) {
        step.checkSpan.textContent = "‚úì";
      }
    }
  }

  // Qu·∫£n l√Ω m√¥ ph·ªèng pipeline B1..B5 & timer B5
  let pipelineInterval = null;
  let pipelineStage = 0; // 0 = ch∆∞a, 1..5 = B1..B5
  let step5Seconds = 0;
  let step5TimerInterval = null;

  function startStep5Timer() {
    const s5 = stepElements[5];
    if (!s5) return;
    step5Seconds = 0;
    if (step5TimerInterval) clearInterval(step5TimerInterval);
    step5TimerInterval = setInterval(() => {
      step5Seconds++;
      s5.timerSpan.textContent = ` (${step5Seconds}s)`;
    }, 1000);
  }

  function stopStep5Timer() {
    if (step5TimerInterval) {
      clearInterval(step5TimerInterval);
      step5TimerInterval = null;
    }
  }

  function startProcessingProgress() {
    resetPipelineStepsUI();
    stopStep5Timer();

    // B·∫Øt ƒë·∫ßu t·ª´ B1
    pipelineStage = 1;
    setStepActive(1);
    statusEl.textContent = pipelineStepsConfig[0].text + "...";

    // B1 -> B4: m·ªói 1.2s ƒë√°nh ‚úì v√† chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo.
    // L·∫ßn tick th·ª© 4: B4 ‚úì v√† chuy·ªÉn sang B5 + b·∫≠t timer, r·ªìi d·ª´ng interval.
    pipelineInterval = setInterval(() => {
      if (pipelineStage >= 1 && pipelineStage <= 3) {
        // ƒë√°nh ‚úì b∆∞·ªõc hi·ªán t·∫°i
        markStepDone(pipelineStage);
        // chuy·ªÉn sang b∆∞·ªõc sau
        pipelineStage++;
        setStepActive(pipelineStage);
        statusEl.textContent =
          pipelineStepsConfig[pipelineStage - 1].text + "...";
      } else if (pipelineStage === 4) {
        // ho√†n th√†nh B4, chuy·ªÉn sang B5 v√† b·∫≠t timer
        markStepDone(4);
        pipelineStage = 5;
        setStepActive(5);
        statusEl.textContent =
          pipelineStepsConfig[4].text + " (ƒëang ch·∫°y, vui l√≤ng ƒë·ª£i...)";
        startStep5Timer();

        clearInterval(pipelineInterval);
        pipelineInterval = null;
      }
    }, 1200);
  }

  function stopProcessingProgress() {
    if (pipelineInterval) {
      clearInterval(pipelineInterval);
      pipelineInterval = null;
    }
    stopStep5Timer();
  }

  // ===== üé® T·∫†O CANVAS S√ìNG √ÇM (WAVEFORM) =====
  const waveformCanvas = document.createElement("canvas");
  waveformCanvas.width = 260;
  waveformCanvas.height = 60;
  waveformCanvas.style.marginTop = "16px";
  waveformCanvas.style.borderRadius = "12px";
  waveformCanvas.style.background = "#e5e7eb";
  document.querySelector(".card").appendChild(waveformCanvas);

  const wctx = waveformCanvas.getContext("2d");

  function clearWaveform() {
    wctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
    wctx.fillStyle = "#e5e7eb";
    wctx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
  }

  clearWaveform();

  // V·∫Ω s√≥ng √¢m gi·ªëng Siri (ƒë∆°n gi·∫£n ho√°)
  function drawWaveform() {
    if (!analyser) return;

    const bufferLength = analyser.fftSize;
    const dataArray = new Uint8Array(bufferLength);
    analyser.getByteTimeDomainData(dataArray);

    // T√≠nh ƒë·ªô "·ªìn" ƒë·ªÉ nh·∫≠n bi·∫øt c√≥ ti·∫øng n√≥i
    let total = 0;
    for (let i = 0; i < bufferLength; i++) {
      const v = dataArray[i] - 128;
      total += Math.abs(v);
    }
    const avg = total / bufferLength; // ~0 ‚Üí im l·∫∑ng, cao h∆°n ‚Üí c√≥ ti·∫øng
    const volumeNorm = avg / 128;     // 0‚Äì1

    const now = Date.now();
    if (volumeNorm > 0.05) {
      lastSoundTime = now;
      statusEl.textContent = "ƒêang ghi √¢m... m·ªùi ƒë·∫∑t c√¢u h·ªèi.";
    } else {
      // N·∫øu im l·∫∑ng > 3 gi√¢y ‚Üí auto STOP
      if (
        mediaRecorder &&
        mediaRecorder.state === "recording" &&
        now - lastSoundTime > SILENCE_LIMIT
      ) {
        statusEl.textContent =
          "Kh√¥ng th·∫•y ti·∫øng trong 3 gi√¢y, h·ªá th·ªëng t·ª± d·ª´ng v√† g·ª≠i c√¢u h·ªèi cho AI.";
        stopRecording(true); // true = auto stop
      }
    }

    // V·∫Ω waveform
    const width = waveformCanvas.width;
    const height = waveformCanvas.height;

    wctx.clearRect(0, 0, width, height);
    wctx.fillStyle = "#e5e7eb";
    wctx.fillRect(0, 0, width, height);

    wctx.lineWidth = 2;
    wctx.strokeStyle = "#2563eb";
    wctx.beginPath();

    const sliceWidth = (width * 1.0) / bufferLength;
    let x = 0;

    for (let i = 0; i < bufferLength; i++) {
      const v = dataArray[i] / 255.0; // 0‚Äì1
      const y = v * height;

      if (i === 0) {
        wctx.moveTo(x, y);
      } else {
        wctx.lineTo(x, y);
      }

      x += sliceWidth;
    }

    wctx.stroke();

    // V·∫Ω "d·∫£i" √°nh s√°ng ·ªü gi·ªØa nh∆∞ Siri
    wctx.fillStyle = "rgba(37, 99, 235, 0.15)";
    const centerY = height / 2;
    const amp = Math.max(4, volumeNorm * (height / 2));
    wctx.fillRect(0, centerY - amp / 2, width, amp);

    animationId = requestAnimationFrame(drawWaveform);
  }

  // ===== üéô B·∫ÆT ƒê·∫¶U GHI √ÇM =====
  startBtn.onclick = async () => {
    try {
      // Khi b·∫Øt ƒë·∫ßu ghi √¢m m·ªõi ‚Üí d·ª´ng ph√°t audio c≈© & reset pipeline
      stopProcessingProgress();
      resetPipelineStepsUI();
      statusEl.textContent = "ƒêang chu·∫©n b·ªã ghi √¢m...";

      audioPlayer.pause();
      audioPlayer.currentTime = 0;
    } catch (e) {
      console.log("Kh√¥ng th·ªÉ d·ª´ng audio (kh√¥ng sao):", e);
    }

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      audioChunks = [];
      mediaRecorder = new MediaRecorder(stream);

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) audioChunks.push(event.data);
      };

      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });

        // B·∫Øt ƒë·∫ßu m√¥ ph·ªèng pipeline x·ª≠ l√Ω ngay khi stop xong
        startProcessingProgress();
        sendAudioToServer(audioBlob);

        // D·ª´ng waveform
        if (animationId) cancelAnimationFrame(animationId);
        animationId = null;
        clearWaveform();

        // T·∫Øt audioContext cho ƒë·ª° t·ªën t√†i nguy√™n
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
      };

      mediaRecorder.start();
      statusEl.textContent = "ƒêang ghi √¢m... m·ªùi ƒë·∫∑t c√¢u h·ªèi.";

      startBtn.disabled = true;
      stopBtn.disabled = false;

      // Thi·∫øt l·∫≠p Web Audio ƒë·ªÉ ƒëo s√≥ng √¢m
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      audioContext = new AudioCtx();
      microphone = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 512;

      microphone.connect(analyser);

      // Ghi nh·∫≠n th·ªùi ƒëi·ªÉm c√≥ ti·∫øng n√≥i g·∫ßn nh·∫•t
      lastSoundTime = Date.now();

      // B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p v·∫Ω waveform
      drawWaveform();
    } catch (err) {
      console.error(err);
      statusEl.textContent =
        "Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c micro. H√£y ki·ªÉm tra quy·ªÅn tr√™n tr√¨nh duy·ªát.";
    }
  };

  // ===== ‚èπ H√ÄM STOP CHUNG (d√πng cho c·∫£ auto stop & click stop) =====
  function stopRecording(isAuto = false) {
    if (mediaRecorder && mediaRecorder.state === "recording") {
      mediaRecorder.stop();
      stopBtn.disabled = true;
      startBtn.disabled = false;

      if (!isAuto) {
        statusEl.textContent =
          "ƒêang k·∫øt th√∫c ghi √¢m, chu·∫©n b·ªã g·ª≠i l√™n h·ªá th·ªëng...";
      }
    }
  }

  // N√∫t Stop do ng∆∞·ªùi d√πng b·∫•m
  stopBtn.onclick = () => {
    stopRecording(false);
  };

  // ===== üì§ G·ª¨I √ÇM THANH L√äN SERVER =====
  async function sendAudioToServer(audioBlob) {
    try {
      const formData = new FormData();
      formData.append("audio", audioBlob, "speech.webm");

      const response = await fetch("/api/voice-chat", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) throw new Error("Server error");

      const data = await response.json();

      // Ngay khi c√≥ k·∫øt qu·∫£ ‚Üí d·ª´ng pipeline m√¥ ph·ªèng & timer B5
      stopProcessingProgress();

      // ƒê·∫£m b·∫£o B1‚ÄìB5 ƒë·ªÅu ‚úì
      for (let i = 1; i <= 5; i++) {
        markStepDone(i);
      }
      // N·∫øu B5 c√≥ ch·∫°y timer th√¨ gi·ªØ l·∫°i s·ªë gi√¢y ƒë√£ ƒë·∫øm
      if (step5Seconds > 0 && stepElements[5]?.timerSpan) {
        stepElements[5].timerSpan.textContent = ` (${step5Seconds}s)`;
      }

      transcriptEl.innerHTML =
        "<b>H·ªçc sinh n√≥i:</b> " + (data.transcript || "(kh√¥ng nh·∫≠n ƒë∆∞·ª£c)");
      aiTextEl.innerHTML =
        "<b>AI tr·∫£ l·ªùi:</b> " + (data.ai_text || "(kh√¥ng nh·∫≠n ƒë∆∞·ª£c)");

      if (data.audio_url) {
        audioPlayer.src = data.audio_url;
        audioPlayer.style.display = "block";

        // B5 xong, chuy·ªÉn sang B6
        setStepActive(6);
        statusEl.textContent =
          "B5: ƒê√£ t·∫°o xong file √¢m thanh. B6: ƒêang chu·∫©n b·ªã ph√°t file √¢m thanh...";

        audioPlayer.play();

        audioPlayer.onplay = () => {
          setStepActive(6);
          statusEl.textContent = "B6: ƒêang ph√°t file √¢m thanh tr·∫£ l·ªùi...";
        };

        audioPlayer.onended = () => {
          markStepDone(6);
          clearActiveSteps();
          statusEl.textContent =
            "Ho√†n th√†nh: ƒê√£ ph√°t xong. B·∫°n c√≥ th·ªÉ b·∫•m Start ƒë·ªÉ h·ªèi ti·∫øp.";
        };
      } else {
        audioPlayer.style.display = "none";
        statusEl.textContent =
          "ƒê√£ x·ª≠ l√Ω xong (ch∆∞a t·∫°o ƒë∆∞·ª£c √¢m thanh, vui l√≤ng ƒë·ªçc c√¢u tr·∫£ l·ªùi tr√™n m√†n h√¨nh).";
      }
    } catch (err) {
      console.error(err);
      stopProcessingProgress();
      statusEl.textContent = "C√≥ l·ªói khi g·ª≠i √¢m thanh l√™n server.";
    }
  }
</script>

</body>
</html>
